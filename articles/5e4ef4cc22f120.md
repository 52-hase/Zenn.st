---
title: "アーキテクチャについて"
emoji: "🙌"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [アーキテクチャ]
published: false
---






[![Image from Gyazo](https://i.gyazo.com/2d42d30ec5605e5428f0312e6811345b.png)](https://gyazo.com/2d42d30ec5605e5428f0312e6811345b)






### フロントエンド
- JavaScript
画面の動的更新（非同期通信 / Ajax）
ユーザー操作に応じた即時UI更新
- Bootstrap
レスポンシブ対応のUIコンポーネント
デザインの統一・実装工数の削減
- RailsのViewと組み合わせて表示を制御

### バックエンド（Heroku上）
- Ruby 3.2.2 + Ruby on Rails 7.1.3
アプリケーションの中核
MVCアーキテクチャを採用
- Controller
リクエストの受付
モデル・外部APIとの連携
- Model（ActiveRecord）
データベース操作
バリデーション・ビジネスロジック管理
- View
フロントエンドへレスポンスを返却

### リアルタイム通信
- WebSocket（ActionCable）
チャットなどのリアルタイム機能を実現
クライアントと双方向通信
ページ更新なしでデータ反映

### データベース
- PostgreSQL
ユーザー情報、投稿データ、音楽データを永続化
ActiveRecord を通じて操作
- Heroku Postgres として運用

### ファイルストレージ
- Active Storage
Rails標準のファイル管理機構
- AWS S3
画像・アップロードファイルの保存先
アプリサーバーとストレージを分離し、拡張性を確保

### 外部API連携
- Spotify Web API（gem rspotify）
楽曲・アーティスト情報の取得
検索・表示機能としてアプリ内で利用
- Rails から外部APIへリクエストを送信

### 開発環境
- Docker
Rails / PostgreSQL / Node.js をコンテナ化
開発環境の統一・再現性を確保
チーム開発や環境構築を容易にする




#### メッセージ送信のユーザー操作
```

ユーザー入力
  ↓
JavaScript（イベント検知・送信データ生成）
  └ 送信ボタンのクリックを検知し、メッセージ内容を取得
  ↓
ActionCable Client（WebSocket送信）
  └ ページ更新なしでRailsへリアルタイム送信
  ↓
Rails Channel（受信・認可・整形）
  └ ユーザー・チャットルームを判別し、受信データを整形
  ↓
ActiveRecord（Message生成・保存）
  └ Messageモデルを作成し、バリデーションを実行
  ↓
PostgreSQL（永続化）
  └ メッセージ内容をデータベースに保存
  ↓
ActionCable（同一ルームへブロードキャスト）
  └ 同じチャットルームに接続中の全ユーザーへ配信
  ↓
JavaScript（受信・DOM更新）
  └ 受信したメッセージを画面に動的追加
  ↓
全ユーザーの画面に即時反映
  └ ページ更新なしでリアルタイム表示


```

#### Spotify楽曲再生のユーザー操作
```
ユーザー操作（再生ボタン）
  ↓
JavaScript（イベント検知・再生データ生成）
  ↓
ActionCable Client（WebSocket送信）
  ↓
Rails Channel（認可・整形・制御）
  ↓
Spotify Web API（rspotify）
  ↓
ActiveRecord（再生状態の保存）
  ↓
PostgreSQL（永続化）
  ↓
ActionCable（ルーム単位ブロードキャスト）
  ↓
JavaScript（受信・再生UI同期）
  ↓
全ユーザーの画面で同時反映ユーザー操作（再生ボタン）
  ↓
JavaScript（イベント検知・再生データ生成）
  └ 再生ボタンのクリックを検知し、楽曲情報を取得
  ↓
ActionCable Client（WebSocket送信）
  └ 再生リクエストをリアルタイムでRailsへ送信
  ↓
Rails Channel（認可・整形・制御）
  └ ユーザー認可・ルーム判定・再生制御を実施
  ↓
Spotify Web API（rspotify）
  └ Spotifyから楽曲情報・再生データを取得
  ↓
ActiveRecord（再生状態の保存）
  └ 再生中の楽曲情報をモデルとして保存
  ↓
PostgreSQL（永続化）
  └ 再生状態をデータベースに記録
  ↓
ActionCable（ルーム単位ブロードキャスト）
  └ 同じルームにいる全ユーザーへ再生状態を配信
  ↓
JavaScript（受信・再生UI同期）
  └ 各ユーザーの再生UIを同期更新
  ↓
全ユーザーの画面で同時反映
  └ 同じ曲・同じ状態をリアルタイム共有


```


#### ① ユーザーがチャットを入力・送信（フロントエンド）
ユーザーがチャット入力欄にメッセージを入力 → 「送信」ボタンをクリック

使用技術
`Rails View`：チャット画面のHTMLを描画
`Bootstrap`：入力フォームやボタンのUIを整える
`JavaScript`：送信イベントを検知、ページ遷移せず処理を実行

#### ② JavaScriptがWebSocket通信を開始
JavaScriptが`ActionCableのChannel`に接続→入力されたメッセージをWebSocket経由で送信

[ポイント]
通常の`HTTP（Ajax）`ではなく、`WebSocket（常時接続）`を使用、ページ更新は発生しない

#### ③ `ActionCable`（Rails）がメッセージを受信
Rails側の`Channelクラス`がメッセージを受け取る→「どのチャットルームか」「誰が送ったか」を識別

使用技術
ActionCableクライアントとサーバーの双方向通信、Heroku上で常時接続を維持

#### ④ Model（ActiveRecord）でDBに保存
`Channel`内で`Messageモデル`を作成 → バリデーションを通過後、DBへ保存

使用技術
ActiveRecordメッセージ内容・ユーザーID・ルームIDを保存
`PostgreSQL（Heroku Postgres）`チャットデータを永続化
ここで行われること空メッセージの防止、ユーザーとチャットルームの紐付け

#### ⑤ 保存成功後、ActionCableでブロードキャスト
保存されたメッセージを同じチャットルームに接続中の全ユーザーへ送信
[ポイント]
サーバー → 複数クライアントへ同時配信、HTTPレスポンスは使わない

#### ⑥ 各ユーザーの画面が即時更新（フロントエンド）
`JavaScript`が受信したメッセージを検知、チャット一覧にHTMLを動的に追加

使用技術
`JavaScriptDOM操作`でメッセージを追加
`Bootstrap`で吹き出し・レイアウトを統一

結果
送信者・受信者 両方の画面に即時反映、ページ更新なしでリアルタイム表示


#### ⑦（補足）画像付きメッセージの場合
画像は `Active Storage`を通してアップロード、ファイル本体は`AWS S3`に保存、DBにはファイルの参照情報のみ保存、チャットには`S3のURL`を表示