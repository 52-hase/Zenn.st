---
title: "アーキテクチャについて"
emoji: "🙌"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [アーキテクチャ]
published: false
---






[![Image from Gyazo](https://i.gyazo.com/2d42d30ec5605e5428f0312e6811345b.png)](https://gyazo.com/2d42d30ec5605e5428f0312e6811345b)






### フロントエンド
- JavaScript
画面の動的更新（非同期通信 / Ajax）
ユーザー操作に応じた即時UI更新
- Bootstrap
レスポンシブ対応のUIコンポーネント
デザインの統一・実装工数の削減
- RailsのViewと組み合わせて表示を制御

### バックエンド（Heroku上）
- Ruby 3.2.2 + Ruby on Rails 7.1.3
アプリケーションの中核
MVCアーキテクチャを採用
- Controller
リクエストの受付
モデル・外部APIとの連携
- Model（ActiveRecord）
データベース操作
バリデーション・ビジネスロジック管理
- View
フロントエンドへレスポンスを返却

### リアルタイム通信
- WebSocket（ActionCable）
チャットなどのリアルタイム機能を実現
クライアントと双方向通信
ページ更新なしでデータ反映

### データベース
- PostgreSQL
ユーザー情報、投稿データ、音楽データを永続化
ActiveRecord を通じて操作
- Heroku Postgres として運用

### ファイルストレージ
- Active Storage
Rails標準のファイル管理機構
- AWS S3
画像・アップロードファイルの保存先
アプリサーバーとストレージを分離し、拡張性を確保

### 外部API連携
- Spotify Web API（gem rspotify）
楽曲・アーティスト情報の取得
検索・表示機能としてアプリ内で利用
- Rails から外部APIへリクエストを送信

### 開発環境
- Docker
Rails / PostgreSQL / Node.js をコンテナ化
開発環境の統一・再現性を確保
チーム開発や環境構築を容易にする




#### メッセージ送信のユーザー操作
```

ユーザー入力
  ↓
JavaScript（イベント検知・送信データ生成）
  └ 送信ボタンのクリックを検知し、メッセージ内容を取得
  ↓
ActionCable Client（WebSocket送信）
  └ ページ更新なしでRailsへリアルタイム送信
  ↓
Rails Channel（受信・認可・整形）
  └ ユーザー・チャットルームを判別し、受信データを整形
  ↓
ActiveRecord（Message生成・保存）
  └ Messageモデルを作成し、バリデーションを実行
  ↓
PostgreSQL（永続化）
  └ メッセージ内容をデータベースに保存
  ↓
ActionCable（同一ルームへブロードキャスト）
  └ 同じチャットルームに接続中の全ユーザーへ配信
  ↓
JavaScript（受信・DOM更新）
  └ 受信したメッセージを画面に動的追加
  ↓
全ユーザーの画面に即時反映
  └ ページ更新なしでリアルタイム表示


メッセージ送信の流れ（簡略）

① ユーザー操作
・ユーザーがメッセージを入力し、送信ボタンをクリック

② JavaScript（イベント検知・送信データ生成）
・送信ボタンのクリックイベントを検知
・入力されたメッセージ内容を取得
・送信用データを作成

③ ActionCable Client（WebSocket送信）
・JavaScriptからWebSocket通信でRailsへデータ送信
・HTTP通信ではないため、ページ更新は発生しない

④ Rails Channel（受信・認可・整形）
・ActionCable Channelがメッセージを受信
・ログインユーザー・チャットルームを判別
・受信データをサーバー側用に整形

⑤ ActiveRecord（Message生成・保存）
・Messageモデルを生成
・バリデーションを実行
・問題なければ保存処理へ

⑥ PostgreSQL（永続化）
・メッセージ内容をデータベースに保存
・チャット履歴として後からも参照可能

⑦ ActionCable（同一ルームへブロードキャスト）
・保存されたメッセージを
・同じチャットルームに接続中の全ユーザーへ配信

⑧ JavaScript（受信・DOM更新）
・各ユーザーのブラウザがメッセージを受信
・JavaScriptでDOMを更新
・新しいメッセージを画面に動的に追加

⑨ 結果
・全ユーザーの画面にメッセージが即時反映
・ページ更新（リロード）は不要
・リアルタイムチャットが実現

```

#### Spotify楽曲再生のユーザー操作
```
ユーザー操作（再生ボタン）
  ↓
JavaScript（イベント検知・再生データ生成）
  ↓
ActionCable Client（WebSocket送信）
  ↓
Rails Channel（認可・整形・制御）
  ↓
Spotify Web API（rspotify）
  ↓
ActiveRecord（再生状態の保存）
  ↓
PostgreSQL（永続化）
  ↓
ActionCable（ルーム単位ブロードキャスト）
  ↓
JavaScript（受信・再生UI同期）
  ↓
全ユーザーの画面で同時反映ユーザー操作（再生ボタン）
  ↓
JavaScript（イベント検知・再生データ生成）
  └ 再生ボタンのクリックを検知し、楽曲情報を取得
  ↓
ActionCable Client（WebSocket送信）
  └ 再生リクエストをリアルタイムでRailsへ送信
  ↓
Rails Channel（認可・整形・制御）
  └ ユーザー認可・ルーム判定・再生制御を実施
  ↓
Spotify Web API（rspotify）
  └ Spotifyから楽曲情報・再生データを取得
  ↓
ActiveRecord（再生状態の保存）
  └ 再生中の楽曲情報をモデルとして保存
  ↓
PostgreSQL（永続化）
  └ 再生状態をデータベースに記録
  ↓
ActionCable（ルーム単位ブロードキャスト）
  └ 同じルームにいる全ユーザーへ再生状態を配信
  ↓
JavaScript（受信・再生UI同期）
  └ 各ユーザーの再生UIを同期更新
  ↓
全ユーザーの画面で同時反映
  └ 同じ曲・同じ状態をリアルタイム共有



① ユーザー操作（再生ボタン）
・ユーザーが再生ボタンをクリック

② JavaScript（イベント検知・再生データ生成）
・再生ボタンのクリックイベントを検知
・再生対象の楽曲情報（SpotifyトラックIDなど）を取得
・再生リクエスト用データを生成

③ ActionCable Client（WebSocket送信）
・WebSocket通信でRailsへ再生リクエストを送信
・ページ更新なしでリアルタイム送信

④ Rails Channel（認可・整形・制御）
・ログインユーザーの認可チェック
・チャット（再生）ルームを判別
・再生制御用にデータを整形・管理

⑤ Spotify Web API（rspotify）
・rspotifyを通してSpotify Web APIを呼び出し
・楽曲情報・再生に必要なデータを取得

⑥ ActiveRecord（再生状態の保存）
・再生中の楽曲・再生状態をモデルとして生成
・バリデーションを実行

⑦ PostgreSQL（永続化）
・再生状態をデータベースに保存
・途中参加ユーザーも現在の再生状況を取得可能

⑧ ActionCable（ルーム単位ブロードキャスト）
・保存された再生状態を
・同じルームに接続中の全ユーザーへ配信

⑨ JavaScript（受信・再生UI同期）
・各ユーザーのブラウザが再生状態を受信
・再生 / 停止 / 楽曲情報などのUIを同期更新

```


#### ① ユーザーがチャットを入力・送信（フロントエンド）
ユーザーがチャット入力欄にメッセージを入力 → 「送信」ボタンをクリック

使用技術
`Rails View`：チャット画面のHTMLを描画
`Bootstrap`：入力フォームやボタンのUIを整える
`JavaScript`：送信イベントを検知、ページ遷移せず処理を実行

#### ② JavaScriptがWebSocket通信を開始
JavaScriptが`ActionCableのChannel`に接続→入力されたメッセージをWebSocket経由で送信

[ポイント]
通常の`HTTP（Ajax）`ではなく、`WebSocket（常時接続）`を使用、ページ更新は発生しない

#### ③ `ActionCable`（Rails）がメッセージを受信
Rails側の`Channelクラス`がメッセージを受け取る→「どのチャットルームか」「誰が送ったか」を識別

使用技術
ActionCableクライアントとサーバーの双方向通信、Heroku上で常時接続を維持

#### ④ Model（ActiveRecord）でDBに保存
`Channel`内で`Messageモデル`を作成 → バリデーションを通過後、DBへ保存

使用技術
ActiveRecordメッセージ内容・ユーザーID・ルームIDを保存
`PostgreSQL（Heroku Postgres）`チャットデータを永続化
ここで行われること空メッセージの防止、ユーザーとチャットルームの紐付け

#### ⑤ 保存成功後、ActionCableでブロードキャスト
保存されたメッセージを同じチャットルームに接続中の全ユーザーへ送信
[ポイント]
サーバー → 複数クライアントへ同時配信、HTTPレスポンスは使わない

#### ⑥ 各ユーザーの画面が即時更新（フロントエンド）
`JavaScript`が受信したメッセージを検知、チャット一覧にHTMLを動的に追加

使用技術
`JavaScriptDOM操作`でメッセージを追加
`Bootstrap`で吹き出し・レイアウトを統一

結果
送信者・受信者 両方の画面に即時反映、ページ更新なしでリアルタイム表示


#### ⑦（補足）画像付きメッセージの場合
画像は `Active Storage`を通してアップロード、ファイル本体は`AWS S3`に保存、DBにはファイルの参照情報のみ保存、チャットには`S3のURL`を表示






# Spotify楽曲再生フロー（詳細版）
#### ① ユーザー操作（再生ボタン）
・ユーザーが楽曲の「再生」ボタンをクリック
・対象のトラックIDを保持

#### ② JavaScript（イベント検知・再生データ生成）
・クリックイベントを検知
・SpotifyのトラックIDを取得
・ルームID・ユーザーIDを含む再生リクエストを生成

```
例：

{
  track_id: "xxxxx",
  room_id: 1
}
```

#### ③ ActionCable Client（WebSocket送信）
・WebSocketでRailsへ再生リクエスト送信
・HTTPではなく常時接続通信を利用
・ページリロードなし

使用技術：
Action Cable

#### ④ Rails Channel（認可・制御）
Channel側で、
・ログインユーザー認証
・対象ルーム判定
・再生権限チェック
・受信データ整形
ここで「不正操作防止」を行う

#### ⑤ Spotify API呼び出し（rspotify）
Rails側から：
・rspotify経由でSpotifyへアクセス
・楽曲情報を取得
・必要に応じて再生制御APIを実行

使用API：
Spotify Web API

#### ⑥ ActiveRecord（再生状態モデル作成）
・再生中楽曲をDBモデル化
・保存内容例：

カラム :
track_id
曲名
アーティスト名
再生開始時刻
ルームID

#### ⑦ PostgreSQL（永続化）
・再生状態を保存
・途中参加ユーザーが現在の再生状況を取得可能
→ ページ更新時にも状態復元できる

#### ⑧ ActionCable（ルーム単位ブロードキャスト）
・保存成功後
・同じルームに接続中の全ユーザーへ配信

特徴：
サーバー → 複数クライアントへ同時配信
HTTPレスポンス不要

#### ⑨ JavaScript（受信・UI同期）
各ブラウザ側で、
・再生状態を受信
・現在の曲情報を表示
・再生/停止ボタン状態更新
・プログレスバー同期