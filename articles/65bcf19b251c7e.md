---
title: "Ruby について理解する"
emoji: "📕"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [Ruby]
published: false
---

# 目的

# 内容

# オブジェクトとは？

| オブジェクトの例          | 種類                         |
| ------------------------- | ---------------------------- |
| 9 　 60 　 900 　 10000   | 整数オブジェクト（Integer）  |
| 1.0 　 5.5 　 1.09 　 0.4 | 少数オブジェクト（Float）    |
| "ワン"　"ok"　"6"         | 文字列オブジェクト（String） |

::::details オブジェクトとは
・Ruby では「もの」です。プログラムの中でデータを持ったり、操作をする対象。
::::

::::details オブジェクトの種類のことをクラスという。
・`Integer`、`Float`、`String` がそれぞれクラスの名前です。
::::

# 変数とは？

```
order = "コーヒー"
puts order

> コーヒー
```

::::details order が変数
・`変数 = オブジェクト`　（変数 order に"コーヒー"を代入すると言う）
・`order` は"カフェオレ"や"カプチーノ"など変わることもあるので、変数で置き換えることで変更は 1 箇所になる。
::::

::::details 変数の名前ルール
・`英字`、`数字`、`_` を使う。先頭は英字小文字か \_ で始める。
・2 単語以上つなげるときは、\_ を間に入れる。これを`スネークケース`と言う。
::::

# 文字列に計算結果を埋め込む

```
#{計算式}　　　 　　（式展開の記法）
```

::::details 式展開の例

```
puts "1 + 1の答えは#{1 + 2}です"

> 1 + 1の答えは3です
```

::::

# irb の使い方

```
$ irb　　　　　　　（irbの起動）
$ exit 　　　（終了）
```

::::details puts メソッドなど使わなくても結果を表示する。

```
MacBook-Air ruby % irb
irb(main):001> 1+2
=> 3
irb(main):002>
```

::::

::::details プログラムの途中で一時停止して irb を使う。

```
a = 2
puts a
```

```
a = 2
binding.irb
puts a
```

::::

# p メソッドとは

::::details p メソッド
・`pメソッド`は後ろに書いた変数やオブジェクトを表示する。
・原則 puts メソッドはプログラム機能として、p メソッドはデバッグの機能として使う。
::::

# 比較メソッド

・比較し正しけれ`true`、正しくなければ`false`で返します。
::::details 大きさを比較するメソッド
`<` と `>`が比較メソッドです。大きさを比較します。

```
puts 1 < 2    （正しいので true
puts 1 > 2    （正しくないので false
```

::::

::::details 条件を満たす場合の比較メソッド
`<=` と `>=`が条件を満たす場合の比較メソッドです。

```
puts 1 <= 2    （正しいので true）
puts 1 => 2    （正しいので true）
```

例

```
wallet = 500　　　　　（財布の残金を表す変数walletに500を代入
puts wallet >= 300  （walletが300以上かの条件

> true
```

```
wallet = 100　　　　　（財布の残金を表す変数walletに100を代入
puts sallet >= 300  （walletが300以上かの条件

> false
```

::::

::::details 等しいことを判断するメソッド
`==` が等しいことを判断する比較メソッドです

```
puts 1 == 1
puts 1 == 2
puts 2 == 1 + 1

> true
> false
> true
```

逆に等しくない場合に`true`を返したいときは `!=`

```
puts 1 != 2
puts 3 != 3

>true
>false
```

::::message
`==`や`!=`は、数値オブジェクトだけでなく、文字列オブジェクトを比較することもできます。
::::

::::details 偶数か奇数かを判断するメソッド
・`even?`メソッドは偶数かどうかを判断する。
・`odd?`メソッドは奇数かどうかを判断する。

```
puts 2.even?
puts 3.even?
puts 2.odd?
puts 3.odd?

>true
>false
>false
>true
```

::::

# if -条件を満たすときの処理

::::details if の使い方

```
if 条件
  条件が成立した時の処理
end
```

「もし財布に 100 円以上入っていればコーヒーを買う」という場合の条件処理

```
wallet = 100
if wallet >= 100
  puts "コーヒーを買う"
end

> コーヒーを買う
```

::::

::::details 後置 if
・行数が短縮され、`end`が省ける。短く読みやすく書くことができる。

```
wallet >= 100
puts "コーヒーを買う" if wallet >= 100

> コーヒーを買う
```

::::

::::details 等しくない場合に true を返す unless
`!=`を使った場合

```
a = 100
if a != 200
  puts "等しくありません"
end

> 等しくありません
```

`unless`を使った場合（if とは反対の働きをする、条件を満たさない時に処理を実行）

```
a = 100
unless a == 200
  puts "等しくありません"
end

> 等しくありません
```

::::

::::message
if の条件が満たされないケースは`false`または`nil`の場合。それ以外は条件を満たすとなる。
::::

# else -条件を満たさないときにも処理をする

::::details else の使い方

`else`の文法

```
if 条件
  条件を満たした場合の処理
else
  条件を満たさなかった場合の処理
end
```

「もし財布に 100 円以上入っていればコーヒーを買う」という場合の条件処理に、`else`で「コーヒーを買わない」と言う分岐処理を加える。

```
wallet = 50
if wallet >= 100
  puts "コーヒーを買う"
else
  puts "コーヒーを買わない"
end

> コーヒーを買わない
```

::::

# elsif -３つ以上の分岐

::::details elsif の使い方
「もし財布に 100 円以上入っていればコーヒーを買う」⇨
「50 円以上入っていればガムを買う」⇨
「満たさない場合は何も買わない」

```
wallet = 50
if wallet >= 100
  puts "コーヒーを買う"
elsif wallet >= 50
  puts "ガムを買う"
else
  puts "何も買わない"
end

> ガムを買う
```

::::

# 複数条件を組み合わせる処理

### 　|| -どちらかの条件を満たすとき「a または b」

::::details ||（または）の使い方
「〇〇である、または、△△ であるとき」

```
if 条件1 || 条件2
  条件を満たしたときの処理
end
```

「もし、財布残金 100 円以上　または、paypay 残高 100 円以上の場合、コーヒーを買う」という`||`を使った複数条件の処理

```
wallet = 50
paypay = 100
if wallet >= 100 || paypay >= 100
  puts "コーヒーを買う"
end

> コーヒーを買う
```

::::

### && -両方の条件を満たすとき「a かつ b」

::::details && の使い方
「〇〇である、かつ、△△ であるとき」

```
if 条件1 && 条件2
  条件を満たしたときの処理
end
```

「もし、財布残金 100 円以上　かつ　晴れている場合、コーヒーを買う」という`&&`を使った複数条件の処理

```
wallet = 100
weather = "fine" 　　（天気は晴れ）
if wallet >= 100 && weather == "fine"
  puts "コーヒーを買う"
end

> コーヒーを買う
```

::::

### && と || 早見表

::::details 表
・表は横方向に読みます。
`条件aがtrue`、`条件bがtrue`のとき、`a && bはtrue`、`a || bもtrue`となります。
| 条件 a | 条件 b | a && b| a ll b |
| ----- | ------ | ----- | ------ |
| true | true | true | true |
| true | false | false | true |
| false | true | false | true |
| false | false | false | false |
::::

# case -複数条件の中から 1 つを選んで分岐する

::::details case の使い方
`case`の文法

```
case 変数
when 候補1
  変数の値が候補1と等しいときの処理    （複数行記載可能）
when 候補2
  変数の値が候補2と等しいときの処置    （複数行記載可能）
（以下、when候補をさらに追加できる）
end
```

例

```
１つ選ぶ 変数が
"コーヒー"のとき
  100円ですと表示
"ガム"のとき
  50円ですと表示
end
```

```
order = "ガム"
case order
when "コーヒー"
  puts "100円です"
when "ガム"
  puts "50円です"
end

> 50円です
```

::::

::::details 複数条件の中に合致するものがない場合 case - else
`else`を追加し、条件が合致しない場合の分岐を作る。

```
order = "ケーキ"
case order
when "コーヒー"
  puts "100円です"
when "ガム"
  puts "50円です"
else
  puts "ありません"
end

> ありません
```

::::

::::message
`if`と`case`の使い分けは、「`if`は 2 つに分岐、`case`は 3 つ以上に分岐」と考える。
::::

# 繰り返す

### times メソッド -決まった回数だけ繰り返す

::::details times メソッドの使い方
`timesメソッド`の文法（n 回繰り返す処理）

```
n.times do
  繰り返し実行する処理
end
```

`do`-`end`の代わりに`{ }`を使うことも可能

```
n.times {
  繰り返し実行する処理
}
```

例

```
2回繰り返す　ここから
  "コーヒー"を表示
end
```

```
2.times do
  puts "コーヒー"
end

> コーヒー
> コーヒー
```

1 回目コーヒーを表示、end まできたら次の繰り返しがあるので do へ戻る。
2 回目の表示、eud まできたら繰り返し回数が終わりなので終了。
::::

::::details times メソッドを 1 行で書く
`timesメソッド`の文法（n 回繰り返す処理）

```
n.times do 繰り返し実行する処理 end
```

```
n.times { 繰り返し実行する処理 }
```

例

```
n.times do puts "コーヒー" end
n.times { puts "ガム }

> コーヒー
> ガム
```

::::

### while -条件を満たしている間ずっと繰り返し処理する

::::details while の使い方 while - end
`while`の文法

```
while 条件
  条件を満たしている間、繰り返し実行する処理
end
```

例

```
cookie = 0
while cookie < 3    (繰り返す条件、cookieは3より少ない)
  cookie = cookie + 1   （変数cookieの値に1を加えて再度代入する）
  puts "ポケットを叩くとクッキーが#{cookie}つ"
end

> ポケットを叩くとクッキーが1つ
> ポケットを叩くとクッキーが2つ
> ポケットを叩くとクッキーが3つ
```

::::

# [ ] -配列

::::details 配列とは
・配列は`[ ]`でオブジェクトをまとめて扱います。配列のクラスは`Array`です。
配列の文法

```
[オブジェクト1, オブジェクト2, オブジェクト3, ・・・]

["コーヒー", "100", "1.09"]   （文字列、整数、少数オブジェクトが入った配列）
["ケーキ"]    （要素が一つの配列）
[ ]   （空の配列）
```

例

```
["コーヒー", "ガム", "ケーキ"]
```

```
p ["コーヒー", "ガム", "ケーキ"]

> ["コーヒー", "ガム", "ケーキ"]
```

::::

::::details 配列を変数に代入する
・配列を代入する変数名は複数形にする。（例: drinks）

```
drinks = ["コーヒー", "カフェラテ", "カプチーノ"]
p drinks

> ["コーヒー", "カフェラテ", "カプチーノ"]
```

::::

::::details 配列の要素の取得
`[0] [1] [2]`で要素の取得

```
drinks = ["コーヒー", "カフェラテ", "カプチーノ"]
puts drinks[0]    > "コーヒー"
puts drinks[1]    > "カフェラテ"
puts drinks[2]    > "カプチーノ"
```

`first メソッド`、`last メソッド`で要素の取得

```
drinks = ["コーヒー", "カフェラテ", "カプチーノ"]
puts drinks.first   > "コーヒー"
puts drinks.last    > "カプチーノ"
```

::::

# nil -何もないことを表すオブジェクト

::::details nil とは
`nil`は、「何もない」ことを表すオブジェクトです。

```
drinks = ["コーヒー", "カフェラテ"]
puts drinks[2]    > nil
```

コーヒーは[0]、カフェラテは[1]なので`nil`が返ります。
::::

# unshift メソッド -要素の追加

::::details unshift メソッドとは
`unshiftメソッド`は、配列の先頭に要素を追加

```
drinks = ["コーヒー"]
drinks.unshift("カフェラテ")    （配列の先頭に追加）
p drinks > ["カフェラテ", "コーヒー"]
```
`push`は、配列の末尾に要素を追加
```
drinks.push("カプチーノ")   （配列の末尾に追加）
p drinks > ["カフェラテ", "コーヒー", "カプチーノ"]
```
`<<`は、`push`と同様に配列の末尾に要素を追加
```
drinks << "ケーキ"    （配列の末尾に追加）
p drinks > ["カフェラテ", "コーヒー", "カプチーノ", "ケーキ"]
```
::::

# 要素の削除をするメソッド
::::details popメソッド と shiftメソッド
```popメソッド```は配列の末尾から要素を1つ削除
```
drinks = ["カフェラテ", "コーヒー", "カプチーノ", "ケーキ"]
drinks.pop
p drinks > ["カフェラテ", "コーヒー", "カプチーノ"]
```
```shiftメソッド```は配列の先頭から要素を1つ削除する
```
drinks = ["カフェラテ", "コーヒー", "カプチーノ", "ケーキ"]
drinks.shift
p drinks > ["コーヒー", "カプチーノ", "ケーキ"]
```
::::
# 配列を足し算、引き算する

::::details 配列の足し算
```
a1 = [1, 2, 3]
a2 = [4, 5, 6]
p a1 + a2

> [1, 2, 3, 4, 5, 6]
```
::::

::::details 配列の引き算
```
a1 = [1, 2, 3]
a2 = [1, 3, 4]
p a1 - a2

> [2]
```
::::

# eachメソッド -配列を繰り返し処理
::::details eachメソッド
```eachメソッド```は配列の全要素を繰り返し処理するメソッドです。
```eachメソッド```の前に書かれた配列の各要素が、変数```|drink|```に繰り返し代入されます。
```
drinks = ["コーヒー", "カプチーノ"]
drinks.each do |drink|
  puts drink
end

> コーヒー
> カプチーノ
```
::::

::::details 繰り返し処理を途中で終わらせる break
```
[1, 2, 3].each do |x|   （配列の各要素を順番に変数xに代入）
  break if x == 3   （xの値が3のときに繰り返しを終わらせる）
  puts x    （変数Xを表示）
end

> 1
> 2
```
::::

::::details 繰り返しの次回へ進む next
```
[1, 2, 3].each do |x|   （配列の各要素を順番に変数xに代入）
  next if x == 2   （xの値が2のときにその処理を終了し、次回の繰り返し処理を開始します）
  puts x    （変数Xを表示）
end

> 1
> 3
```
::::

::::details

::::

:::details

::::

::::details

::::

:::details

::::

::::details

::::

:::details

::::

::::details

::::

:::details

::::

::::details

::::

:::details

::::

::::details

::::

:::details

::::
