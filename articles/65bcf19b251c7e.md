---
title: "Ruby について理解する"
emoji: "📕"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [Ruby]
published: false
---

# 目的

# 内容

# オブジェクトとは？

| オブジェクトの例          | 種類                         |
| ------------------------- | ---------------------------- |
| 9 　 60 　 900 　 10000   | 整数オブジェクト（Integer）  |
| 1.0 　 5.5 　 1.09 　 0.4 | 少数オブジェクト（Float）    |
| "ワン"　"ok"　"6"         | 文字列オブジェクト（String） |

::::details オブジェクトとは
・Ruby では「もの」です。プログラムの中でデータを持ったり、操作をする対象。
::::

::::details オブジェクトの種類のことをクラスという。
・`Integer`、`Float`、`String` がそれぞれクラスの名前です。
::::

# 変数とは？

```
order = "コーヒー"
puts order

> コーヒー
```

::::details order が変数
・`変数 = オブジェクト`　（変数 order に"コーヒー"を代入すると言う）
・`order` は"カフェオレ"や"カプチーノ"など変わることもあるので、変数で置き換えることで変更は 1 箇所になる。
::::

::::details 変数の名前ルール
・`英字`、`数字`、`_` を使う。先頭は英字小文字か \_ で始める。
・2 単語以上つなげるときは、\_ を間に入れる。これを`スネークケース`と言う。
::::

# 文字列に計算結果を埋め込む

```
#{計算式}　　　 　　（式展開の記法）
```

::::details 式展開の例

```
puts "1 + 1の答えは#{1 + 2}です"

> 1 + 1の答えは3です
```

::::

# irb の使い方

```
$ irb　　　　　　　（irbの起動）
$ exit 　　　（終了）
```

::::details puts メソッドなど使わなくても結果を表示する。

```
MacBook-Air ruby % irb
irb(main):001> 1+2
=> 3
irb(main):002>
```

::::

::::details ir の中でメソッドを呼び出したい場合
・メソッドの`def`から`end`までを`コピー & ペースト`する。
・その後、メソッドを入力すると値が表示される。（`nunber(10)メソッド`を入力）

```
irb(main):002* def nunber(10)
irb(main):003*   response = []
irb(main):004*   (1..10).each do |n|
irb(main):005*     if n % 10 == 0
irb(main):006*       response << "いちご"
irb(main):007*     elsif n % 3 == 0
irb(main):008*       response << "みかん"
irb(main):009*     elsif n % 5 == 0
irb(main):010*       response << "りんご"
irb(main):011*     else
irb(main):012*       response << n
irb(main):013*     end
irb(main):014*   end
irb(main):015*   response
irb(main):016> end
=> :nunber
irb(main):017> nunber(10)
=> [1, 2, "みかん", 4, "りんご", "みかん", 7, 8, "みかん", "いちご"]
```

::::

::::details プログラムの途中で一時停止して irb を使う。

```
a = 2
puts a
```

```
a = 2
binding.irb
puts a
```

::::

# p メソッドとは

::::details p メソッド
・`pメソッド`は後ろに書いた変数やオブジェクトを表示する。
・原則 puts メソッドはプログラム機能として、p メソッドはデバッグの機能として使う。
::::

# 比較メソッド

・比較し正しけれ`true`、正しくなければ`false`で返します。
::::details 大きさを比較するメソッド
`<` と `>`が比較メソッドです。大きさを比較します。

```
puts 1 < 2    （正しいので true）
puts 1 > 2    （正しくないので false）
```

::::

::::details 条件を満たす場合の比較メソッド
`<=` と `>=`が条件を満たす場合の比較メソッドです。

```
puts 1 <= 2    （正しいので true）
puts 1 => 2    （正しいので true）
```

例

```
wallet = 500　　　　　（財布の残金を表す変数walletに500を代入）
puts wallet >= 300  （walletが300以上かの条件）

> true
```

```
wallet = 100　　　　　（財布の残金を表す変数walletに100を代入）
puts wallet >= 300  （walletが300以上かの条件）

> false
```

::::

::::details 等しいことを判断するメソッド
`==` が等しいことを判断する比較メソッドです

```
puts 1 == 1
puts 1 == 2
puts 2 == 1 + 1

> true
> false
> true
```

逆に等しくない場合に`true`を返したいときは `!=`

```
puts 1 != 2
puts 3 != 3

>true
>false
```

::::message
`==`や`!=`は、数値オブジェクトだけでなく、文字列オブジェクトを比較することもできます。
::::

::::details 偶数か奇数かを判断するメソッド
・`even?`メソッドは偶数かどうかを判断する。
・`odd?`メソッドは奇数かどうかを判断する。

```
puts 2.even?
puts 3.even?
puts 2.odd?
puts 3.odd?

>true
>false
>false
>true
```

::::

# if -条件を満たすときの処理

::::details if の使い方

```
if 条件
  条件が成立した時の処理
end
```

「もし財布に 100 円以上入っていればコーヒーを買う」という場合の条件処理

```
wallet = 100
if wallet >= 100
  puts "コーヒーを買う"
end

> コーヒーを買う
```

::::

::::details 後置 if
・行数が短縮され、`end`が省ける。短く読みやすく書くことができる。

```
wallet >= 100
puts "コーヒーを買う" if wallet >= 100

> コーヒーを買う
```

::::

::::details 等しくない場合に true を返す -unless
`!=`を使った場合

```
a = 100
if a != 200
  puts "等しくありません"
end

> 等しくありません
```

`unless`を使った場合（if とは反対の働きをする、条件を満たさない時に処理を実行）

```
a = 100
unless a == 200
  puts "等しくありません"
end

> 等しくありません
```

::::

::::message
if の条件が満たされないケースは`false`または`nil`の場合。それ以外は条件を満たすとなる。
::::

# else -条件を満たさないときにも処理をする

::::details else の使い方

`else`の文法

```
if 条件
  条件を満たした場合の処理
else
  条件を満たさなかった場合の処理
end
```

「もし財布に 100 円以上入っていればコーヒーを買う」という場合の条件処理に、`else`で「コーヒーを買わない」と言う分岐処理を加える。

```
wallet = 50
if wallet >= 100
  puts "コーヒーを買う"
else
  puts "コーヒーを買わない"
end

> コーヒーを買わない
```

::::

# elsif -３つ以上の分岐

::::details elsif の使い方
「もし財布に 100 円以上入っていればコーヒーを買う」⇨
「50 円以上入っていればガムを買う」⇨
「満たさない場合は何も買わない」

```
wallet = 50
if wallet >= 100
  puts "コーヒーを買う"
elsif wallet >= 50
  puts "ガムを買う"
else
  puts "何も買わない"
end

> ガムを買う
```

::::

# 複数条件を組み合わせる処理

### 　|| -どちらかの条件を満たすとき「a または b」

::::details ||（または）の使い方
「〇〇である、または、△△ であるとき」

```
if 条件1 || 条件2
  条件を満たしたときの処理
end
```

「もし、財布残金 100 円以上　または、paypay 残高 100 円以上の場合、コーヒーを買う」という`||`を使った複数条件の処理

```
wallet = 50
paypay = 100
if wallet >= 100 || paypay >= 100
  puts "コーヒーを買う"
end

> コーヒーを買う
```

::::

### && -両方の条件を満たすとき「a かつ b」

::::details && の使い方
「〇〇である、かつ、△△ であるとき」

```
if 条件1 && 条件2
  条件を満たしたときの処理
end
```

「もし、財布残金 100 円以上　かつ　晴れている場合、コーヒーを買う」という`&&`を使った複数条件の処理

```
wallet = 100
weather = "fine" 　　（天気は晴れ）
if wallet >= 100 && weather == "fine"
  puts "コーヒーを買う"
end

> コーヒーを買う
```

::::

### && と || 早見表

::::details 表
・表は横方向に読みます。
`条件aがtrue`、`条件bがtrue`のとき、`a && bはtrue`、`a || bもtrue`となります。
| 条件 a | 条件 b | a && b| a ll b |
| ----- | ------ | ----- | ------ |
| true | true | true | true |
| true | false | false | true |
| false | true | false | true |
| false | false | false | false |
::::

# case -複数条件の中から 1 つを選んで分岐する

::::details case の使い方
`case`の文法

```
case 変数
when 候補1
  変数の値が候補1と等しいときの処理    （複数行記載可能）
when 候補2
  変数の値が候補2と等しいときの処置    （複数行記載可能）
（以下、when候補をさらに追加できる）
end
```

例

```
１つ選ぶ 変数が
"コーヒー"のとき
  100円ですと表示
"ガム"のとき
  50円ですと表示
end
```

```
order = "ガム"
case order
when "コーヒー"
  puts "100円です"
when "ガム"
  puts "50円です"
end

> 50円です
```

::::

::::details 複数条件の中に合致するものがない場合 case - else
`else`を追加し、条件が合致しない場合の分岐を作る。

```
order = "ケーキ"
case order
when "コーヒー"
  puts "100円です"
when "ガム"
  puts "50円です"
else
  puts "ありません"
end

> ありません
```

::::

::::message
`if`と`case`の使い分けは、「`if`は 2 つに分岐、`case`は 3 つ以上に分岐」と考える。
::::

# 繰り返す

### times メソッド -決まった回数だけ繰り返す

::::details times メソッドの使い方
`timesメソッド`の文法（n 回繰り返す処理）

```
n.times do
  繰り返し実行する処理
end
```

`do`-`end`の代わりに`{ }`を使うことも可能

```
n.times {
  繰り返し実行する処理
}
```

例

```
2回繰り返す　ここから
  "コーヒー"を表示
end
```

```
2.times do
  puts "コーヒー"
end

> コーヒー
> コーヒー
```

1 回目コーヒーを表示、end まできたら次の繰り返しがあるので do へ戻る。
2 回目の表示、eud まできたら繰り返し回数が終わりなので終了。
::::

::::details times メソッドを 1 行で書く
`timesメソッド`の文法（n 回繰り返す処理）

```
n.times do 繰り返し実行する処理 end
```

```
n.times { 繰り返し実行する処理 }
```

例

```
n.times do puts "コーヒー" end
n.times { puts "ガム }

> コーヒー
> ガム
```

::::

### while -条件を満たしている間ずっと繰り返し処理する

::::details while の使い方 while - end
`while`の文法

```
while 条件
  条件を満たしている間、繰り返し実行する処理
end
```

例

```
cookie = 0
while cookie < 3    (繰り返す条件、cookieは3より少ない)
  cookie = cookie + 1   （変数cookieの値に1を加えて再度代入する）
  puts "ポケットを叩くとクッキーが#{cookie}つ"
end

> ポケットを叩くとクッキーが1つ
> ポケットを叩くとクッキーが2つ
> ポケットを叩くとクッキーが3つ
```

::::

# [ ] -配列

::::details 配列とは
・配列は`[ ]`でオブジェクトをまとめて扱います。配列のクラスは`Array`です。
配列の文法

```
[オブジェクト1, オブジェクト2, オブジェクト3, ・・・]

["コーヒー", "100", "1.09"]   （文字列、整数、少数オブジェクトが入った配列）
["ケーキ"]    （要素が一つの配列）
[ ]   （空の配列）
```

例

```
["コーヒー", "ガム", "ケーキ"]
```

```
p ["コーヒー", "ガム", "ケーキ"]

> ["コーヒー", "ガム", "ケーキ"]
```

::::

::::details 配列を変数に代入する
・配列を代入する変数名は複数形にする。（例: drinks）

```
drinks = ["コーヒー", "カフェラテ", "カプチーノ"]
p drinks

> ["コーヒー", "カフェラテ", "カプチーノ"]
```

::::

::::details 配列の要素の取得
`[0] [1] [2]`で要素の取得

```
drinks = ["コーヒー", "カフェラテ", "カプチーノ"]
puts drinks[0]    > "コーヒー"
puts drinks[1]    > "カフェラテ"
puts drinks[2]    > "カプチーノ"
```

`first メソッド`、`last メソッド`で要素の取得

```
drinks = ["コーヒー", "カフェラテ", "カプチーノ"]
puts drinks.first   > "コーヒー"
puts drinks.last    > "カプチーノ"
```

::::

# nil -何もないことを表すオブジェクト

::::details nil とは
`nil`は、「何もない」ことを表すオブジェクトです。

```
drinks = ["コーヒー", "カフェラテ"]
puts drinks[2]    > nil
```

コーヒーは[0]、カフェラテは[1]なので`nil`が返ります。
::::

# unshift メソッド -要素の追加

::::details unshift メソッドとは
`unshiftメソッド`は、配列の先頭に要素を追加

```
drinks = ["コーヒー"]
drinks.unshift("カフェラテ")    （配列の先頭に追加）
p drinks > ["カフェラテ", "コーヒー"]
```

`push`は、配列の末尾に要素を追加

```
drinks.push("カプチーノ")   （配列の末尾に追加）
p drinks > ["カフェラテ", "コーヒー", "カプチーノ"]
```

`<<`は、`push`と同様に配列の末尾に要素を追加

```
drinks << "ケーキ"    （配列の末尾に追加）
p drinks > ["カフェラテ", "コーヒー", "カプチーノ", "ケーキ"]
```

::::

# 要素の削除をするメソッド

::::details pop メソッド と shift メソッド
`popメソッド`は配列の末尾から要素を 1 つ削除

```
drinks = ["カフェラテ", "コーヒー", "カプチーノ", "ケーキ"]
drinks.pop
p drinks > ["カフェラテ", "コーヒー", "カプチーノ"]
```

`shiftメソッド`は配列の先頭から要素を 1 つ削除する

```
drinks = ["カフェラテ", "コーヒー", "カプチーノ", "ケーキ"]
drinks.shift
p drinks > ["コーヒー", "カプチーノ", "ケーキ"]
```

::::

# 配列を足し算、引き算する

::::details 配列の足し算

```
a1 = [1, 2, 3]
a2 = [4, 5, 6]
p a1 + a2

> [1, 2, 3, 4, 5, 6]
```

::::

::::details 配列の引き算

```
a1 = [1, 2, 3]
a2 = [1, 3, 4]
p a1 - a2

> [2]
```

::::

# each メソッド -配列を繰り返し処理

::::details each メソッド
`eachメソッド`は配列の全要素を繰り返し処理するメソッドです。
`eachメソッド`の前に書かれた配列の各要素が、変数`|drink|`に繰り返し代入されます。

```
drinks = ["コーヒー", "カプチーノ"]
drinks.each do |drink|
  puts drink
end

> コーヒー
> カプチーノ
```

::::

::::details 繰り返し処理を途中で終わらせる -break

```
[1, 2, 3].each do |x|   （配列の各要素を順番に変数xに代入）
  break if x == 3   （xの値が3のときに繰り返しを終わらせる）
  puts x    （変数Xを表示）
end

> 1
> 2
```

::::

::::details 繰り返しの次回へ進む -next

```
[1, 2, 3].each do |x|   （配列の各要素を順番に変数xに代入）
  next if x == 2   （xの値が2のときにその処理を終了し、次回の繰り返し処理を開始します）
  puts x    （変数Xを表示）
end

> 1
> 3
```

::::

::::details 範囲を指定し繰り返す -Range オブジェクト
文法

```
配列.each do |変数|
  繰り返す実行する処理
end
```

例
「2 から 5 までの数を 1 ずつ増やして繰り返したい」場合の処理。
`2..5`は範囲を表す`Rangeオブジェクト`

```
(2..5).each do |x|
  puts x
end

> 2
> 3
> 4
> 5
```

::::

# 配列のさまざまなメソッド

[class Array(リファレンスマニュアル)](https://docs.ruby-lang.org/ja/3.2/class/Array.html)
[るりまサーチ](https://rurema.clear-code.com/)
::::details 配列の要素数を返す -size メソッド
・`sizeメソッド`は配列の要素数を返す。
・数字だけでなくいろいろなオブジェクトを返すことができます。

```
puts [0, 1, 9].size

> 3
```

::::

::::details 配列の全要素を足す -sum メソッド
`sumメソッド`は配列の全要素を足す。

```
puts [6, 9, 10].sum

> 25
```

::::

::::details 平均値の計算 -size、sum メソッド
`sum ÷ size = 平均値`（合計 ÷ 要素数 = 平均値）

```
a = [1, 5, 9]
puts a.sum / a.size

> 5
```

::::

::::details uniq メソッドと uniq!メソッドの違い
`uniqメソッド`は、重複した要素を取り除く

```
array1 = [1, 1, 2]
array2 = array1.uniq

p array1 > [1, 1, 2]    (array1自身は変わらない)
p array2 > [1, 2]
```

`uniq!メソッド`は、自分自身の配列オブジェクトも重複した要素を取り除き`破壊的変更`をする

```
array1 = [1, 1, 2]
array2 = array1.uniq!

p array1 > [1, 2]    (array1自身も重複が取り除かれる)
p array2 > [1, 2]
```

::::

::::message
末尾に`!`が付かないメソッドは、新しい配列オブジェクトを作って返すものが多い
末尾に`!`が付くメソッドは、オブジェクトを破壊的に変更するものが多い
::::

### ブロックを渡せるメソッド

::::details ブロックを渡せるメソッドの例
・`uniqメソッド`にブロックを渡さない場合

```
p [1, 2, 3, "2", "3"].uniq

> [1, 2, 3, "2", "3"]
```

・`uniqメソッド`にブロックを渡す場合 　　 `{ |n| n.to_s }` ⇦ これがブロック
・`{ |n| n.to_s }`このブロックは、`n`は変数、`to_s`は、文字列へ変換するメソッド
　　　　　　　　　　　　　　　　　　　　　　　　　　　（`1 は "1"`と変換します）

```
p [1, 2, 3, "2", "3"].uniq { |n| n.to_s }

> [1, 2, 3]
```

・ブロック`{ |n| n.to_s }`で配列の各要塞を文字列に変換し`[1, 2, 3, "2", "3"]`は、`["1", "2", "3", "2", "3"]`となる。

・元の配列、`[1, 2, 3, "2", "3"]`の要素自体が変わるわけではない。そのため、結果は文字列ではなく、元の配列の要素の型を保ったまま、重複排除された`[1, 2, 3]`を返すことになる。
::::

# 配列の要素を並び替える

:::details 配列の要素を順に並び替える -sort メソッド
・`sortメソッド`は配列の要素を並び替える。

要素が数値のときは、`小さい`順に並び替える。

```
p [6, 10, 9].sort

> [6, 9, 10]
```

要素が文字列のときは`abc`順に並び替える。先頭が同じであれば`2文字目で比較`、大文字が混じる場合は`大文字が先、小文字が後`となる。

```
p ["kumo", "yuki", "ame"].sort
p ["asa", "yuki", "ame"].sort
p ["asa", "Yuki", "ame"].sort

> ["ame", "kumo", "yuki"]
> ["ame", "asa", "yuki"]
> ["Yuki", "ame", "asa"]
```

::::

::::details 大きい順に並び替える -reverse メソッド
`reverseメソッド`は配列の並び順を逆にする。

```
p [6, 10, 9].sort
p [6, 10, 9].sort.reverse

> [6, 9, 10]
> [10, 9, 6]
```

::::

:::details 文字列を逆にする -reverse メソッド
`reverseメソッド`は配列のほか、文字列にも適応される。

```
p "abc".reverse
p "あいう".reverse

> "cba"
> "ういあ"
```

::::

# 配列を文字列を変換する

### join メソッド -配列中の文字列を連結する

::::details join メソッドの使い方
`joinメソッド`は配列の要素の文字列を連結して、1 つの文字列にする。

```
puts ["コーヒー"].join
puts ["コーヒー", "ケーキ"].join
puts ["コーヒー", "ケーキ", "アイス"].join

> コーヒー
> コーヒーケーキ
> コーヒーケーキアイス
```

・`join("と")`のように書くと、各要素の間に`「と」`を入れて連結する。
・要素が 1 つの場合は、`「と」`は入らない。

```
puts ["コーヒー"].join("と")
puts ["コーヒー", "ケーキ"].join("と")
puts ["コーヒー", "ケーキ", "アイス"].join("と")

> コーヒー
> コーヒーとケーキ
> コーヒーとケーキとアイス
```
::::




:::details

::::

::::details

::::

:::details

::::

::::details

::::

:::details

::::

::::details

::::

:::details

::::

::::details

::::

:::details

::::
