---
title: "TypeScriptについて"
emoji: "📚"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [TypeScript]
published: false
---
### 開発環境
- macOS
- VSCode

<br>
<br>
<br>

# TypeScriptとは？
- `TypeScript`とは、JavaScriptに型（Type）を付け加えた言語
- `.ts`や`.tsx`という拡張子で使用
- 変数や関数の引数・戻り値などに型を指定できる



| 項目             | TypeScript                                     | JavaScript                              |
|------------------|------------------------------------------------|------------------------------------------|
| 型の仕組み       | 静的型付け（コンパイル時に型をチェック）       | 動的型付け（実行時に型が決まる）        |
| コンパイルの必要 | 必要（.ts → .jsに変換）                        | 不要（直接ブラウザやNode.jsで実行）     |
| IDEサポート      | 型情報による強力な補完と警告                   | 補完や警告は限定的                      |
| エラーチェック   | コンパイル時に型エラーを検出                   | 実行時にエラーが発覚                     |
| 開発対象         | 主に中〜大規模向け                             | 小〜大規模まで（特に小規模に向く）      |
| オブジェクト指向 | インターフェース・継承などが強力にサポート     | ES6以降で限定的にサポート               |
| 実行速度         | JSと同等（最終的にはJSに変換される）           | 高速（直接実行）                         |
| 学習コスト       | 高め（型システムの理解が必要）                 | 低め（柔軟で簡単に始められる）           |


<br>


| 項目     | メリット                                                                 | デメリット                                      |
|----------|--------------------------------------------------------------------------|-------------------------------------------------|
| 型安全性 | コンパイル時に型チェックが行われ、バグを未然に防ぎやすい               | 型定義の作成や調整に手間がかかることがある      |
| 保守性   | 大規模開発でもコードの一貫性と可読性を保ちやすい                         | 型の修正が広範囲に影響することがある            |
| 補完機能 | エディタでの自動補完やリファクタリングが強力                            | 学習コストが高く、初学者には難しく感じられる    |
| ドキュメント性 | 型情報がそのまま仕様書代わりになる                                  | ライブラリによっては型定義ファイルの導入が必要   |
| バグ発見 | 実行前に多くのエラーを発見できる                                         | 柔軟性が落ちるため、動的なコードには不向きな場合がある |


<br>

## よく使われる重要な型

| 型の種類 | 概要 | 使用例 |
| --- | --- | --- |
| `string` | 文字列型を表す | `let name: string = "Taro";` |
| `number` | 数値型（整数・小数を含む）を表す | `let age: number = 25;` |
| `boolean` | 真偽値型。`true` または `false` のみを取る | `let isActive: boolean = true;` |
| `undefined` | 値が未定義であることを表す | `let value: undefined = undefined;` |
| `null` | null 値を表す | `let nothing: null = null;` |
| ユニオン型 | 複数の型のどれかであることを表す | `let id: number | string;` |
| 配列型 | 同じ型の要素を持つ配列 | `let scores: number[] = [90, 80];` |
| オブジェクト型 | プロパティを持つ構造化された型 | `let user: { name: string; age: number }` |
| 型エイリアス | `type` を使って型に名前をつけられる | `type User = { name: string };` |
| インターフェース | オブジェクトの構造を定義する方法の1つ | `interface User { name: string }` |

## その他の型（特定の場面で使用）

| 型の種類 | 概要 | 使用例 |
| --- | --- | --- |
| `any` | どんな型でも許容する（型安全性が失われる） | `let data: any = "hello";` |
| `unknown` | `any` に似ているが、安全に扱うには型の確認が必要 | `let input: unknown = 10;` |
| `void` | 関数が値を返さないことを示す型 | `function greet(): void {}` |
| `never` | 決して値を返さない（例外を投げる関数など） | `function error(): never { throw new Error(); }` |
| リテラル型 | 決まった文字列や数値など特定の値のみを許容する | `let direction: "left" | "right";` |
| タプル型 | 決まった型と順番の配列を表す | `let point: [number, number] = [1, 2];` |
| 列挙型（enum） | 特定の値セットを定義するための構文 | `enum Direction { Up, Down }` |


<br>

| 注意点                          | 内容                                                                 | 例または補足                                                                 |
|-------------------------------|----------------------------------------------------------------------|------------------------------------------------------------------------------|
| 型定義の明確化                 | 型を明示的に指定することで、予期しない型エラーを防ぐ                    | `const count: number = 0;`                                                   |
| anyの使用を避ける             | `any`型は型安全性を損なうため、極力使用を避ける                         | `unknown`を使って、処理前に型チェックを行う                                 |
| 型推論に頼りすぎない           | 型推論は便利だが、複雑なコードでは意図しない型になる場合がある         | 明示的な型アノテーションを追加する                                          |
| インターフェースと型エイリアス | 使い分けに注意。拡張には`interface`、ユニオン型には`type`が便利          | `interface User { name: string }` vs `type Status = "success" | "error"` |
| null/undefinedの扱い           | 厳密なnullチェックを行わないと実行時エラーの原因になる                  | オプショナルチェイニング `user?.name` やnull合体演算子 `??` を活用         |
| 非同期関数の型指定             | `Promise<型>` を戻り値として明示することで可読性と型安全性が向上         | `const fetchData = async (): Promise<Data> => { ... }`                      |
| 型の再利用                     | 同じ型を複数箇所で定義しないで、共通化して再利用する                    | `type Props = { ... }` を定義し複数の関数で使用                              |
| ESLint/TSLintとの併用          | 型チェックを補完するために静的解析ツールを導入する                      | `@typescript-eslint` のルール設定                                            |
| tsconfigの設定確認             | コンパイルオプションで型チェックの厳しさが変わる                         | `strict: true` を推奨                                                        |


<br>


### 以上です。

<br>
<br>
<br>