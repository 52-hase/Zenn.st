---
title: "Action Cableについて"
emoji: "📚"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [ActionCable]
published: false
---
### 開発環境
- macOS
- VSCode
- Rails 7.1.3.3
- ruby-3.2.3


#### 行いたいこと
　RailsガイドのAction Cableについて自分なりにわかりやすいように噛み砕いたので覚書として記載する。
https://railsguides.jp/action_cable_overview.html
<br>
<br>


# Action Cableとは
　`Action Cable`は、`フロントエンドのWebSocket`と`バックエンドのRails環境`をシームレスに統合する、フルスタックなフレームワークです。

　つまり、フロントエンドとバックエンドの間でスムーズな通信を可能にし、開発者がRails環境で効率的にリアルタイム機能を構築できるようにします。

# WebSocketとは
　`WebSocket`とは、Webアプリケーションにおいてサーバーと`クライアント`間で`双方向のリアルタイム通信`を実現するための`プロトコル`です。

従来のHTTPプロトコルでは、クライアントからのリクエストに対してサーバーが応答する`一方向の通信モデル`でしたが、`WebSocket`ではコネクションを確立した後は、サーバー側からもクライアントにデータを送信できる`双方向の通信`が可能になります。

つまり、Action Cableでは、`通常のHTTPリクエスト・レスポンスプロトコル`の代わりに`WebSocket`を利用します。
:::message
`プロトコル`とは？
　`プロトコル`とは、コンピュータやデバイス間で通信を行うための規則や手順を定めた取り決めです。これはデータの送受信方法 , 形式 , 順序 , エラー処理などを明確に定義したものです。

`クライアント`とは？
　この場合の`クライアント`とは、主にWebブラウザやモバイルアプリなど、WebSocketを使用してサーバーと通信を行う`エンドユーザー側のアプリケーションやソフトウェア`を指します。
:::




# コネクションとは
　`コネクション（connection）`とは、クライアントとサーバーを繋ぐ通信経路のことです。

　Action Cableサーバーは、複数の`WebSocketコネクション`を同時に扱うことができ、それぞれに対応する`コネクションインスタンス`が生成されます。

　例えば、同じユーザーが複数のブラウザタブを開いたり、異なるデバイスを使用した場合、それぞれ独立した`WebSocketコネクション`が確立され、アプリケーションと接続されます。

:::message 
・`コネクションインスタンス`とは？
　`コネクションインスタンス`とは、Action Cableサーバーが各WebSocket接続を管理するために作成するオブジェクト（データと機能をまとめたもの）のことです。
:::




# WebSocketコネクション
　`WebSocketコネクション`とは、クライアントとサーバーの間で`双方向のリアルタイム通信を可能にする通信方式`のことです。

　通常の`HTTP通信`では、クライアントがリクエストを送るたびにサーバーがレスポンスを返しますが、`WebSocket`では一度接続が確立されると、サーバーとクライアントの間で常にデータをやり取りできる状態が維持されます。



# コンシューマーとは
　`WebSocketのクライアント`は`コンシューマー（consumer）`と呼ばれます。

Action Cableでは、クライアント側のJavaScriptフレームワークを使って、この`コンシューマー`を作成します。
　ここで言う「`コンシューマーを作成します`」 とは、`WebSocket接続を確立し、サーバーとリアルタイム通信を行うための仕組みを準備する`ことを指します。








# チャネルとは
　`チャネル`とは、それぞれ特定の機能を担当する通信の単位で、`MVCのコントローラーのようにデータのやり取りや処理`を行います。

　コンシューマー（WebSocketのクライアント）は必ず1つ以上のチャネルを`サブスクライブ`する必要があり、複数のチャネルを同時にサブスクライブすることもできます。
　

例
`ChatChannel` → チャットのメッセージを送受信する。
`AppearancesChannel` → ユーザーのオンライン状態を管理する。
　1つのコンシューマーは、これらのチャネルの`どちらか一方、または両方`をサブスクライブできます。





:::message
`サブスクライブ`とは？
`サブスクライブ`とは、WebSocketなどのリアルタイム通信システムにおいて、クライアント（コンシューマー）が特定のチャネルからの情報を受け取るために、そのチャネルへの`「情報受信設定の登録」を開始する`ことを意味します。
:::


# サブスクライバとは
　`サブスクライバ`とは、WebSocketなどのリアルタイム通信システムにおいて、特定のチャネルをサブスクライブしている`コンシューマー`のことです。

　`コンシューマー`がチャネルをサブスクライブすると、そのコンシューマーはそのチャネルの`サブスクライバ`になります。

　`サブスクライバ`とチャネルの間の接続は「`サブスクリプション`」と呼ばれます。一人のコンシューマーは同じチャネルに複数回サブスクライブすることも可能で、例えば複数のチャットルームを同時にサブスクライブできます。



# Pub/Subとは
　`Pub/Sub`とは、
　`情報を送る側（Publisher/パブリッシャ）`が「誰に送るか」を直接指定せず、代わりに「どんな種類の情報か」という分類でメッセージを発信するシステムです。
　`情報を受け取る側（Subscriber/サブスクライバー）`は、自分が興味のある情報の種類を登録しておき、関連するメッセージが発信されたときだけ通知を受け取ります。

　この`Pub/Sub`は、`メッセージキュー`の`パラダイム`の一種で、メッセージの`非同期処理`と一時保管の機能を提供します。

　送信者は「チャネル」や「トピック」といった`抽象化された宛先（抽象クラス）`にメッセージを送信します。

　`Pub/Sub`の主な利点は、送信者と受信者の`疎結合`を実現することです。

　`送信者`はどの受信者がメッセージを受け取るかを知る必要がなく、`受信者`も誰がメッセージを送信したかを必ずしも知る必要がありません。これにより、`多対多の通信が効率化`されます。

:::message 
`メッセージキュー`とは？
（メッセージを一時的に保存するところ）

`パラダイム`とは？
（ある分野における基本的な考え方や概念の枠組み）

`非同期処理`とは？
（処理の開始と完了を別々のタイミングで行う方式）

`疎結合`とは？
　（システムやコンポーネント間の依存関係が最小限に抑えられている状態）
:::


# ブロードキャストとは
`ブロードキャスト（broadcasting）`とは、`情報の送信者（ブロードキャスター/broadcaster）`によって転送されるあらゆる情報を、チャネルの`受信者（サブスクライバ）`に直接送信するための`pub/subリンク`のことを指します。

`サブスクライバ`は、その名前を持つブロードキャストの情報を継続的に受信（ストリーミング）します。また、各チャネルは、`0個以上のブロードキャストを同時にストリーミングする`ことができます。




# サーバー側のコンポネート（Rails側）
### コネクション（Connection）


`基本的な仕組み`
・サーバーがWebSocketを1個受信するたびに、コネクションオブジェクトのインスタンスが生成される。
・このオブジェクトは、後に作成されるすべてのチャネルサブスクリプションの親オブジェクトとなる。
・認証と認可の後は、コネクション自身はアプリケーションロジックを扱わない。


`コンシューマー（Consumer）について`
・WebSocketコネクションのクライアントは`コンシューマー（Consumer）`と呼ばれる。
・ユーザーが新しい`「ブラウザタブ」「ウィンドウ」「デバイス」`で接続するたびに、`コンシューマコネクション`が1個ずつ作成される。


`技術的な構成`
・コネクションは`ApplicationCable::Connection`のインスタンスである。
・`ApplicationCable::Connection`は`ActionCable::Connection::Base`を継承している。
・`ApplicationCable::Connection`では、ユーザーを識別できる場合に限り、認証後に接続を確立する。


```rb:app/channels/application_cable/connection.rb
module ApplicationCable
  class Connection < ActionCable::Connection::Base
    identified_by :current_user

    def connect
      self.current_user = find_verified_user
    end

    private
      def find_verified_user
        if verified_user = User.find_by(id: cookies.encrypted[:user_id])
          verified_user
        else
          reject_unauthorized_connection
        end
      end
  end
end
```

:::details コードの解説
```rb:app/channels/application_cable/connection.rb
module ApplicationCable


 # 技術的な構成: コネクションは`ApplicationCable::Connection`のインスタンスである
 # 技術的な構成: `ApplicationCable::Connection`は`ActionCable::Connection::Base`を継承している
 class Connection < ActionCable::Connection::Base


   # 基本的な仕組み: このオブジェクトは後に作成されるすべてのチャネルサブスクリプションの親オブジェクトとなる
   # ユーザー識別のための設定
   identified_by :current_user


   # 基本的な仕組み: サーバーがWebSocketを1個受信するたびに接続が確立される
   # 技術的な構成: ユーザーを識別できる場合に限り、認証後に接続を確立する
   def connect
     self.current_user = find_verified_user
   end

   private


     # 基本的な仕組み: 認証と認可の処理を行う部分
     def find_verified_user


       # cookieからユーザーIDを取得して認証する
       if verified_user = User.find_by(id: cookies.encrypted[:user_id])
         verified_user
       else


         # 認証失敗時は接続を拒否する
         reject_unauthorized_connection
       end
     end
 end
end
```
:::



### 例外ハンドリング


```rb:app/channels/application_cable/connection.rb
module ApplicationCable
  class Connection < ActionCable::Connection::Base
    rescue_from StandardError, with: :report_error

    private
      def report_error(e)
        SomeExternalBugtrackingService.notify(e)
      end
  end
end
```
:::details コード解説

```rb:app/channels/application_cable/connection.rb
# デフォルトでは、捕捉されなかった例外は Rails のログに出力される。
# しかし、これらの例外をグローバルに処理し、外部のバグトラッキングサービスに通知することも可能。
# その場合、rescue_from を使用してエラーハンドリングを行う。

module ApplicationCable
  class Connection < ActionCable::Connection::Base


    # StandardError（標準的なエラー）を捕捉し、report_error メソッドで処理する
    rescue_from StandardError, with: :report_error

    private


      # エラーが発生した際に、外部のバグトラッキングサービスに通知を送る
      def report_error(e)
        SomeExternalBugtrackingService.notify(e) # 例: `Sentry`や`Bugsnag`などのサービスを利用
      end
  end
end
```
`ApplicationCable::Connectionクラスの解説`
・このコードは Rails の Action Cable における接続クラスの定義です
・ActionCable::Connection::Base を継承して WebSocket 接続を管理します
・主な機能は例外処理（エラーハンドリング）の設定です

`例外処理機能`
・rescue_from メソッドを使用して例外を捕捉しています
・StandardError（ほとんどの一般的なエラー）が対象です
・エラー発生時は :report_error メソッドが呼び出されます

`report_errorメソッド`
・捕捉したエラーを外部サービスに通知する役割があります
・引数 e として捕捉された例外オブジェクトを受け取ります
・SomeExternalBugtrackingService.notify(e) でエラー情報を送信します
・実際の実装では Sentry や Bugsnag などの実際のサービス名が使われます

`設計上のポイント`
・プライベートメソッドとして定義されているため、外部からは直接呼び出せません
・Action Cable 全体でのグローバルなエラーハンドリングを実現しています
・エラーを記録するだけでなく、外部サービスへの通知も行います
:::

### チャネル（Channel）

`チャネルとは`
・チャネルは特定の機能や処理をまとめる単位
・MVC設計パターンでのコントローラに似た役割を果たす
・Action Cableのコア機能の一つ

`ApplicationCable::Channel`
・チャネルジェネレータを初めて使うと自動的に作成される
・ActionCable::Channel::Baseを継承している
・複数のチャネル間で共有されるロジックをカプセル化する親クラス

`システム構造における位置づけ`
・チャネルは実際の機能ロジックを実装する場所
・複数のチャネルで共通の機能は親クラスに配置できる
・MVCアーキテクチャの考え方をリアルタイム通信にも適用している

<br>

#### 親チャネルと個別チャネルの設計


`ApplicationCable::Channel - すべてのチャネルの親クラス（親チャネルの設定）`
```rb:app/channels/application_cable/channel.rb
module ApplicationCable
 # 役割: 共通機能を提供し、すべての独自チャネルがこれを継承する
 # ActionCable::Channel::Baseを継承して基本的なチャネル機能を取得
 class Channel < ActionCable::Channel::Base
 end
end
```

`ChatChannel - チャット機能専用のチャネル`
```rb:app/channels/chat_channel.rb
# 役割: チャットメッセージの送受信、プレゼンス管理などの
# チャット関連のビジネスロジックを実装する
# ApplicationCable::Channelを継承して共通機能を取得
class ChatChannel < ApplicationCable::Channel
end
```

`AppearanceChannel - ユーザーのオンライン状態を管理するチャネル`
```rb:app/channels/appearance_channel.rb
# 役割: ユーザーのログイン状態、オンライン/オフライン状態の変更通知、
# アクティビティステータスなどを管理
# ApplicationCable::Channelを継承して共通機能を取得
class AppearanceChannel < ApplicationCable::Channel
end
```

<br>

これらの記載で`クライアント側からコンシューマーがチャネルをサブスクライブ`できるようになります。（ブラウザなどがWebSocketを通じて特定のチャネルに接続し、リアルタイム通信を利用できるようになります）




<br>
<br>
<br>



<br>
<br>
<br>